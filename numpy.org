:PROPERTIES:
:ID:       a3134371-c437-4772-ab5e-9fd3e23aa653
:ROAM_ALIASES: numpy
:END:
#+title: Numpy

* Built-in methods to create arrays
** ~array~
#+begin_src python :session
np.array([[1,2,3],[4,5,6],[7,8,9]])
# array([[1, 2, 3],
#        [4, 5, 6],
#        [7, 8, 9]])
#+end_src

** ~arange~
#+begin_src python :session
np.arange(0, 11, 2)
# array([ 0,  2,  4,  6,  8, 10])
#+end_src

** ~zeros~, ~ones~
#+begin_src python :session
np.zeros((5, 5))
# array([[0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.]])
#+end_src

** ~linspace~
Return ~n~ evenly spaced numbers over ~[a, b]~ (both inclusive).
#+begin_src python :session
np.linspace(0, 5, 21)
# array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  , 2.25, 2.5 ,
#        2.75, 3.  , 3.25, 3.5 , 3.75, 4.  , 4.25, 4.5 , 4.75, 5.  ])
#+end_src

** ~eye~
Creates an identity matrix.
#+begin_src python :session
np.eye(4)
# array([[1., 0., 0., 0.],
#        [0., 1., 0., 0.],
#        [0., 0., 1., 0.],
#        [0., 0., 0., 1.]])
#+end_src

* Random
** ~seed~
#+begin_src python :session
np.random.seed(42)
np.random.rand(4)
# array([0.37454012, 0.95071431, 0.73199394, 0.59865848])
#+end_src

** ~rand~
Creates an array of the given shape populated with random samples from a
*uniform distribution* over [0, 1].
#+begin_src python :session
np.random.rand(5,5)
# array([[0.03932992, 0.80719137, 0.50145497, 0.68816102, 0.1216304 ],
#        [0.44966851, 0.92572848, 0.70802042, 0.10461719, 0.53768331],
#        [0.12201904, 0.5940684 , 0.89979774, 0.3424078 , 0.77421593],
#        [0.53191409, 0.0112285 , 0.3989947 , 0.8946967 , 0.2497392 ],
#        [0.5814085 , 0.37563686, 0.15266028, 0.42948309, 0.26434141]])
#+end_src

** ~randn~
Uses the *standard distribution* (σ = 1) to populate the array.
#+begin_src python :session
np.random.randn(2)
# array([-0.36633217, -1.40298731])
#+end_src

** ~randint~
Returns random integers from ~low~ (inclusive) to ~high~ (exclusive).
#+begin_src python :session
np.random.randint(0, 100)
# 71
np.random.randint(0, 10, 9)
# array([7, 7, 0, 4, 4, 5, 9, 1, 8])
#+end_src

* Array attributes and methods
** ~reshape~
(~rows~, ~columns~)
#+begin_src python :session
np.arange(0, 25).reshape(5, 5)
# array([[ 0,  1,  2,  3,  4],
#        [ 5,  6,  7,  8,  9],
#        [10, 11, 12, 13, 14],
#        [15, 16, 17, 18, 19],
#        [20, 21, 22, 23, 24]])
#+end_src

** ~min~, ~max~, ~argmin~, ~argmax~
#+begin_src python :session
arr = np.random.randint(0, 100, 10)
arr
# array([82, 86, 74, 74, 87, 99, 23,  2, 21, 52])
arr.max()
# 99
arr.min()
# 2
arr.argmax()
# 5
arr.argmin()
# 7
#+end_src

** ~shape~
(~rows~, ~columns~)
#+begin_src python :session
np.arange(0, 25).shape # Note that this array would better be displayed
# vertically to match the shape. However, numpy displays it horizontaly.
# (25,)
#+end_src
** ~ndim~
#+begin_src python :session
np.arange(0, 125).reshape(5, 5, 5).ndim
# 3
#+end_src
** ~dtype~
#+begin_src python :session
arr = np.arange(0, 25, dtype='float16') # intx, uintx, floatx
arr.dtype
# dtype('float16')
#+end_src

** ~size~
Returns the length of the array.
#+begin_src python :session
a = np.array([3, 1, 5, 2, 5, 1, 1, 5, 1, 4, 2, 1, 4, 5, 3, 4, 5, 2, 4, 2, 6, 6, 3, 6, 2, 3, 5, 6, 5])
a.size
# 20
#+end_src
** ~itemsize~
Number of bytes that the underlying data type requires to store one element.
#+begin_src python :session
np.array([1, 2, 3], dtype=np.uint64).itemsize
# 8
#+end_src
* Indexing and slicing
** Slicing 1-D
Regular slicing methods used in lists apply. Slice will point to the original
arrays memory, which is not the case in regular lists.
#+begin_src python :session
l1 = list(range(0, 10))
l2 = l1[:5] # [:] operator shallow copies elements to a new array
l1[1] = 100
l2
# [0, 1, 2, 3, 4]

a1 = np.arange(0, 10)
a2 = a1[:5]
a1[1] = 100
a2
# array([  0, 100,   2,   3,   4])
#+end_src
** ~copy~
#+begin_src python :session
a1 = np.arange(0, 10)
a2 = a1[:5].copy()
a1[1] = 100
a2
# array([0, 1, 2, 3, 4])
#+end_src
** Broadcasting
#+begin_src python :session
arr = np.arange(0, 10)
arr[:5] = 100
arr
# array([100, 100, 100, 100, 100,   5,   6,   7,   8,   9])
#+end_src
** Slicing 2-D
Using ~:~ is important when slicing. It changes the shape of the output. Using
~:~ keeps the shape.
#+begin_src python :session
a = np.arange(0, 100, 5).reshape(4, 5)
a
# array([[ 0,  5, 10, 15, 20],
#        [25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70],
#        [75, 80, 85, 90, 95]])

a[1:3]
# array([[25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70]])

a[1:3,2:]
# array([[35, 40, 45],
#        [60, 65, 70]])

a[1:, 3:4] # != a[1:, 3]
# array([[40],
#        [65],
#        [90]])
a[1:, 3]
# array([40, 65, 90])
#+end_src

* Conditional selection
Includes a pointer to the original array.
#+begin_src python :session
a = np.random.randint(0, 10, 20)
a
# array([7, 2, 0, 3, 2, 9, 6, 0, 9, 6, 5, 6, 0, 5, 3, 6, 1, 1, 0, 2])
gt5 = a > 5
a[gt5]
# array([7, 9, 6, 9, 6, 6, 6])

a[gt5] *= 10
# array([70,  2,  0,  3,  2, 90, 60,  0, 90, 60,  5, 60,  0,  5,  3, 60,  1,
#         1,  0,  2])
#+end_src

* Operations
** ~+~, ~-~, ~/~, ~*~
Division by zero will not cause an error. Instead it will issue a warning.
#+begin_src python :session
a = np.array([5, 7, 1, 0])
a / 2
# array([2.5, 3.5, 0.5, 0. ])

a / a
# 1: RuntimeWarning: invalid value encountered in divide
# array([ 1.,  1.,  1., nan])

a / 0
# 1: RuntimeWarning: divide by zero encountered in divide
# 1: RuntimeWarning: invalid value encountered in divide
# array([inf, inf, inf, nan])
#+end_src
* Data types
** Numpy data types
Here are some of the types that numpy supports. Consult the documentation for
more information.
| Data type                                                       | Description            |
|-----------------------------------------------------------------+------------------------|
| ~bool_~, ~bool8~                                                | Boolean                |
| ~int_~, ~intc~, ~intp~, ~int8~, ~int16~, ~int32~, ~int64~       | Integer types          |
| ~uint~, ~uintc~, ~uintp~, ~uint8~, ~uint16~, ~uint32~, ~uint64~ | Unsigned integer types |
| ~float_~, ~float16~, ~float32~, ~float64~                       | Float types            |
| ~complex_~, ~complex64~, ~complex128~                           | Complex types          |
** Constructing with data type
#+begin_src python :session
np.array([1, 2, 3, 4, 5], dtype=np.float16)
# array([1., 2., 3., 4., 5.], dtype=float16)
#+end_src
** Structured arrays
Structured arrays are ndarrays whose datatype is a composition of simpler
datatypes organized as a sequence of named fields. They closely mimic C ~struct~ for low-level manipulation and interpretation of binary blobs.

1. A list of tuples can be used to express the layout.
   ~np.dtype([(fieldname, datatype, shape), ...])~ where ~shape~ is optional.
2. A string of comma-seperated dtype specifications.
#+begin_src python :session
np.dtype('i8, f4, S3, ...')
# dtype([('f0', '<i8'), ('f1', '<f4'), ('f2', 'S3'), ...])
#+end_src
3. A dictionary of field parameter arrays. This is the most flexible option.
   * ~names~, ~formats~ have to be specified and must be of the same length.
   * ~offsets~ specifies the offset of each column from the start.
   * ~itemsize~ specifies the total size of the structure. It must be able to
     contain the structure.
#+begin_src python :session
np.dtype({'names': ['col1', 'col2'], 'formats': ['i4', 'f4']})
# dtype([('col1', '<i4'), ('col2', '<f4')])
np.dtype({'names':   ['col1', 'col2'],
          'formats': ['i4',   'f4'],
          'offsets': [0,      4],
          'itemsize': 12})
# dtype({'names': ['col1', 'col2'], 'formats': ['<i4', '<f4'], 'offsets': [0, 4], 'itemsize': 12})
#+end_src
4. A dictionary of field names.
#+begin_src python :session
np.dtype({'col1': ('i1', 0), 'col2': ('f4', 1)})
# dtype([('col1', 'i1'), ('col2', '<f4')])
#+end_src

#+begin_src python :session
population = np.dtype([('country', 'U20'), ('density', '=i4'), ('area', '=i4'), ('population', '=i4')])
table = np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000),
    ('Germany', 233, 357021, 81799600),
    ('Liechtenstein', 205, 160, 32842),
    ('Italy', 192, 301230, 59715625),
    ('Switzerland', 177, 41290, 7301994),
    ('Luxembourg', 173, 2586, 512000),
    ('France', 111, 547030, 63601002),
    ('Austria', 97, 83858, 8169929),
    ('Greece', 81, 131940, 11606813),
    ('Ireland', 65, 70280, 4581269),
    ('Sweden', 20, 449964, 9515744),
    ('Finland', 16, 338424, 5410233),
    ('Norway', 13, 385252, 5033675),
], dtype=population)
#+end_src
** Endiannes
- ~'<i8'~ use little-endian. x86 architecture and some Arm chips use this
  format.
- ~'>i8'~ use big-endian. This format should be used when transmitting data over
  a network.
- ~'=i8'~ use native-endiannes of the system. It is system-dependant, so
  shouldn't be use accross systems.
