:PROPERTIES:
:ID:       a3134371-c437-4772-ab5e-9fd3e23aa653
:ROAM_ALIASES: numpy
:END:
#+title: Numpy

* Built-in methods to create arrays
** ~array~
#+begin_src python  :session :exportss both
import numpy as np
np.array([[1,2,3],[4,5,6],[7,8,9]])
#+end_src

#+RESULTS:
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

** ~arange~
#+begin_src python  :session :exports both
import numpy as np
np.arange(0, 11, 2)
#+end_src

#+RESULTS:
| 0 | 2 | 4 | 6 | 8 | 10 |

** ~zeros~, ~ones~
#+begin_src python  :session :exports both
import numpy as np
np.zeros((5, 5))
#+end_src

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 |

** ~linspace~
Return ~n~ evenly spaced numbers over ~[a, b]~ (both inclusive).
#+begin_src python  :session :exports both
import numpy as np
np.linspace(0, 5, 11)
#+end_src

#+RESULTS:
| 0 | 0.5 | 1 | 1.5 | 2 | 2.5 | 3 | 3.5 | 4 | 4.5 | 5 |

** ~eye~
Creates an identity matrix.
#+begin_src python  :session :exports both
import numpy as np
np.eye(4)
#+end_src

#+RESULTS:
| 1 | 0 | 0 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 0 | 0 | 1 |

* Random
** ~seed~
#+begin_src python  :session :exports both
import numpy as np
np.random.seed(42)
np.random.rand(4)
#+end_src

#+RESULTS:
| 0.37454012 | 0.95071431 | 0.73199394 | 0.59865848 |

** ~rand~
Creates an array of the given shape populated with random samples from a
*uniform distribution* over [0, 1].
#+begin_src python  :session :exports both
import numpy as np
np.random.rand(5,5)
#+end_src

#+RESULTS:
| 0.15601864 | 0.15599452 | 0.05808361 | 0.86617615 | 0.60111501 |
| 0.70807258 | 0.02058449 | 0.96990985 | 0.83244264 | 0.21233911 |
| 0.18182497 | 0.18340451 | 0.30424224 | 0.52475643 | 0.43194502 |
| 0.29122914 | 0.61185289 | 0.13949386 | 0.29214465 | 0.36636184 |
| 0.45606998 | 0.78517596 | 0.19967378 | 0.51423444 | 0.59241457 |

** ~randn~
Uses the *standard distribution* (Ïƒ = 1) to populate the array.
#+begin_src python  :session :exports both
import numpy as np
np.random.randn(2)
#+end_src

#+RESULTS:
| 0.12221917 | -0.51543566 |

** ~randint~
Returns random integers from ~low~ (inclusive) to ~high~ (exclusive).
#+begin_src python  :session :exports both
import numpy as np
np.random.randint(0, 100)
np.random.randint(0, 10, 9)
#+end_src

#+RESULTS:
| 3 | 7 | 6 | 8 | 7 | 4 | 1 | 4 | 7 |

* Array attributes and methods
** ~reshape~
(~rows~, ~columns~)
#+begin_src python  :session :exports both
import numpy as np
np.arange(0, 25).reshape(5, 5)
#+end_src

#+RESULTS:
|  0 |  1 |  2 |  3 |  4 |
|  5 |  6 |  7 |  8 |  9 |
| 10 | 11 | 12 | 13 | 14 |
| 15 | 16 | 17 | 18 | 19 |
| 20 | 21 | 22 | 23 | 24 |

** ~min~, ~max~, ~argmin~, ~argmax~
#+begin_src python  :session :exports both
arr = np.random.randint(0, 100, 10)
arr
# array([82, 86, 74, 74, 87, 99, 23,  2, 21, 52])
arr.max()
# 99
arr.min()
# 2
arr.argmax()
# 5
arr.argmin()
# 7
#+end_src

** ~shape~
(~rows~, ~columns~)
#+begin_src python  :session :exports both
np.arange(0, 25).shape # Note that this array would better be displayed
# vertically to match the shape. However, numpy displays it horizontaly.
# (25,)
#+end_src

** ~ndim~
#+begin_src python  :session :exports both
np.arange(0, 125).reshape(5, 5, 5).ndim
# 3
#+end_src
** ~dtype~
#+begin_src python  :session :exports both
import numpy as np
arr = np.arange(0, 25, dtype='float16') # intx, uintx, floatx
arr.dtype
# dtype('float16')
#+end_src

** ~size~
Returns the length of the array.
#+begin_src python  :session :exports both
a = np.array([3, 1, 5, 2, 5, 1, 1, 5, 1, 4, 2, 1, 4, 5, 3, 4, 5, 2, 4, 2, 6, 6, 3, 6, 2, 3, 5, 6, 5])
a.size
# 20
#+end_src
** ~itemsize~
Number of bytes that the underlying data type requires to store one element.
#+begin_src python  :session :exports both
np.array([1, 2, 3], dtype=np.uint64).itemsize
# 8
#+end_src
* Indexing and slicing
** Slicing 1-D
Regular slicing methods used in lists apply. Slice will point to the original
arrays memory, which is not the case in regular lists.
#+begin_src python  :session :exports both
import numpy as np
l1 = list(range(0, 10))
l2 = l1[:5] # [:] operator shallow copies elements to a new array
l1[1] = 100
l2
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

#+begin_src python  :session :exports both
a1 = np.arange(0, 10)
a2 = a1[:5]
a1[1] = 100
a2
#+end_src

#+RESULTS:
| 0 | 100 | 2 | 3 | 4 |

** ~copy~
#+begin_src python  :session :exports both
import numpy as np
a1 = np.arange(0, 10)
a2 = a1[:5].copy()
a1[1] = 100
a2
#+end_src

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

** Broadcasting
#+begin_src python  :session :exports both
import numpy as np
arr = np.arange(0, 10)
arr[:5] = 100
arr
#+end_src

#+RESULTS:
| 100 | 100 | 100 | 100 | 100 | 5 | 6 | 7 | 8 | 9 |

** Slicing 2-D
Using ~:~ is important when slicing. It changes the shape of the output. Using
~:~ keeps the shape.
#+begin_src python  :session :exports both
a = np.arange(0, 100, 5).reshape(4, 5)
a
# array([[ 0,  5, 10, 15, 20],
#        [25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70],
#        [75, 80, 85, 90, 95]])

a[1:3]
# array([[25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70]])

a[1:3,2:]
# array([[35, 40, 45],
#        [60, 65, 70]])

a[1:, 3:4] # != a[1:, 3]
# array([[40],
#        [65],
#        [90]])
a[1:, 3]
# array([40, 65, 90])
#+end_src

* Conditional selection
Includes a pointer to the original array.
#+begin_src python  :session :exports both
a = np.random.randint(0, 10, 20)
a
# array([7, 2, 0, 3, 2, 9, 6, 0, 9, 6, 5, 6, 0, 5, 3, 6, 1, 1, 0, 2])
gt5 = a > 5
a[gt5]
# array([7, 9, 6, 9, 6, 6, 6])

a[gt5] *= 10
# array([70,  2,  0,  3,  2, 90, 60,  0, 90, 60,  5, 60,  0,  5,  3, 60,  1,
#         1,  0,  2])
#+end_src

* Operations
** ~+~, ~-~, ~/~, ~*~
Division by zero will not cause an error. Instead it will issue a warning.
#+begin_src python  :session :exports both
a = np.array([5, 7, 1, 0])
a / 2
# array([2.5, 3.5, 0.5, 0. ])

a / a
# 1: RuntimeWarning: invalid value encountered in divide
# array([ 1.,  1.,  1., nan])

a / 0
# 1: RuntimeWarning: divide by zero encountered in divide
# 1: RuntimeWarning: invalid value encountered in divide
# array([inf, inf, inf, nan])
#+end_src
* Data types
** Numpy data types
Here are some of the types that numpy supports. Consult the documentation for
more information.
| Data type                                                       | Description            |
|-----------------------------------------------------------------+------------------------|
| ~bool_~, ~bool8~                                                | Boolean                |
| ~int_~, ~intc~, ~intp~, ~int8~, ~int16~, ~int32~, ~int64~       | Integer types          |
| ~uint~, ~uintc~, ~uintp~, ~uint8~, ~uint16~, ~uint32~, ~uint64~ | Unsigned integer types |
| ~float_~, ~float16~, ~float32~, ~float64~                       | Float types            |
| ~complex_~, ~complex64~, ~complex128~                           | Complex types          |
** Constructing with data type
#+begin_src python  :session :exports both
np.array([1, 2, 3, 4, 5], dtype=np.float16)
# array([1., 2., 3., 4., 5.], dtype=float16)
#+end_src
** Structured arrays
Structured arrays are ndarrays whose datatype is a composition of simpler
datatypes organized as a sequence of named fields. They closely mimic C ~struct~ for low-level manipulation and interpretation of binary blobs.

1. A list of tuples can be used to express the layout.
   ~np.dtype([(fieldname, datatype, shape), ...])~ where ~shape~ is optional.
2. A string of comma-seperated dtype specifications.
#+begin_src python  :session :exports both
np.dtype('i8, f4, S3, ...')
# dtype([('f0', '<i8'), ('f1', '<f4'), ('f2', 'S3'), ...])
#+end_src
3. A dictionary of field parameter arrays. This is the most flexible option.
   * ~names~, ~formats~ have to be specified and must be of the same length.
   * ~offsets~ specifies the offset of each column from the start.
   * ~itemsize~ specifies the total size of the structure. It must be able to
     contain the structure.
#+begin_src python  :session :exports both
np.dtype({'names': ['col1', 'col2'], 'formats': ['i4', 'f4']})
# dtype([('col1', '<i4'), ('col2', '<f4')])
np.dtype({'names':   ['col1', 'col2'],
          'formats': ['i4',   'f4'],
          'offsets': [0,      4],
          'itemsize': 12})
# dtype({'names': ['col1', 'col2'], 'formats': ['<i4', '<f4'], 'offsets': [0, 4], 'itemsize': 12})
#+end_src
4. A dictionary of field names.
#+begin_src python  :session :exports both
np.dtype({'col1': ('i1', 0), 'col2': ('f4', 1)})
# dtype([('col1', 'i1'), ('col2', '<f4')])
#+end_src

#+begin_src python  :session :exports both
import numpy as np
population = np.dtype([('country', 'U20'), ('density', '=i4'), ('area', '=i4'), ('population', '=i4')])
np.array([
    ('Netherlands', 393, 41526, 16928800),
    ('Belgium', 337, 30510, 11007020),
    ('United Kingdom', 256, 243610, 62262000),
    ('Germany', 233, 357021, 81799600),
    ('Liechtenstein', 205, 160, 32842),
    ('Italy', 192, 301230, 59715625),
    ('Switzerland', 177, 41290, 7301994),
    ('Luxembourg', 173, 2586, 512000),
    ('France', 111, 547030, 63601002),
    ('Austria', 97, 83858, 8169929),
    ('Greece', 81, 131940, 11606813),
    ('Ireland', 65, 70280, 4581269),
    ('Sweden', 20, 449964, 9515744),
    ('Finland', 16, 338424, 5410233),
    ('Norway', 13, 385252, 5033675),
], dtype=population)
#+end_src

#+RESULTS:
| Netherlands    | 393 |  41526 | 16928800 |
| Belgium        | 337 |  30510 | 11007020 |
| United Kingdom | 256 | 243610 | 62262000 |
| Germany        | 233 | 357021 | 81799600 |
| Liechtenstein  | 205 |    160 |    32842 |
| Italy          | 192 | 301230 | 59715625 |
| Switzerland    | 177 |  41290 |  7301994 |
| Luxembourg     | 173 |   2586 |   512000 |
| France         | 111 | 547030 | 63601002 |
| Austria        |  97 |  83858 |  8169929 |
| Greece         |  81 | 131940 | 11606813 |
| Ireland        |  65 |  70280 |  4581269 |
| Sweden         |  20 | 449964 |  9515744 |
| Finland        |  16 | 338424 |  5410233 |
| Norway         |  13 | 385252 |  5033675 |

** Endiannes
- ~'<i8'~ use little-endian. x86 architecture and some Arm chips use this
  format.
- ~'>i8'~ use big-endian. This format should be used when transmitting data over
  a network.
- ~'=i8'~ use native-endiannes of the system. It is system-dependant, so
  shouldn't be use accross systems.
