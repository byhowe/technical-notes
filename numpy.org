:PROPERTIES:
:ID:       a3134371-c437-4772-ab5e-9fd3e23aa653
:ROAM_ALIASES: numpy
:END:
#+title: Numpy

* Built-in methods to create arrays
** ~array~
#+begin_src python
np.array([[1,2,3],[4,5,6],[7,8,9]])
# array([[1, 2, 3],
#        [4, 5, 6],
#        [7, 8, 9]])
#+end_src

** ~arange~
#+begin_src python
np.arange(0, 11, 2)
# array([ 0,  2,  4,  6,  8, 10])
#+end_src

** ~zeros~, ~ones~
#+begin_src python
np.zeros((5, 5))
# array([[0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.],
#        [0., 0., 0., 0., 0.]])
#+end_src

** ~linspace~
Return ~n~ evenly spaced numbers over ~[a, b]~ (both inclusive).
#+begin_src python
np.linspace(0, 5, 21)
# array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  , 2.25, 2.5 ,
#        2.75, 3.  , 3.25, 3.5 , 3.75, 4.  , 4.25, 4.5 , 4.75, 5.  ])
#+end_src

** ~eye~
Creates an identity matrix.
#+begin_src python
np.eye(4)
# array([[1., 0., 0., 0.],
#        [0., 1., 0., 0.],
#        [0., 0., 1., 0.],
#        [0., 0., 0., 1.]])
#+end_src

* Random
** ~seed~
#+begin_src python
np.random.seed(42)
np.random.rand(4)
# array([0.37454012, 0.95071431, 0.73199394, 0.59865848])
#+end_src

** ~rand~
Creates an array of the given shape populated with random samples from a
*uniform distribution* over [0, 1].
#+begin_src python
np.random.rand(5,5)
# array([[0.03932992, 0.80719137, 0.50145497, 0.68816102, 0.1216304 ],
#        [0.44966851, 0.92572848, 0.70802042, 0.10461719, 0.53768331],
#        [0.12201904, 0.5940684 , 0.89979774, 0.3424078 , 0.77421593],
#        [0.53191409, 0.0112285 , 0.3989947 , 0.8946967 , 0.2497392 ],
#        [0.5814085 , 0.37563686, 0.15266028, 0.42948309, 0.26434141]])
#+end_src

** ~randn~
Uses the *standard distribution* (Ïƒ = 1) to populate the array.
#+begin_src python
np.random.randn(2)
# array([-0.36633217, -1.40298731])
#+end_src

** ~randint~
Returns random integers from ~low~ (inclusive) to ~high~ (exclusive).
#+begin_src python
np.random.randint(0, 100)
# 71
np.random.randint(0, 10, 9)
# array([7, 7, 0, 4, 4, 5, 9, 1, 8])
#+end_src

* Array attributes and methods
** ~reshape~
(~rows~, ~columns~)
#+begin_src python
np.arange(0, 25).reshape(5, 5)
# array([[ 0,  1,  2,  3,  4],
#        [ 5,  6,  7,  8,  9],
#        [10, 11, 12, 13, 14],
#        [15, 16, 17, 18, 19],
#        [20, 21, 22, 23, 24]])
#+end_src

** ~min~, ~max~, ~argmin~, ~argmax~
#+begin_src python
arr = np.random.randint(0, 100, 10)
arr
# array([82, 86, 74, 74, 87, 99, 23,  2, 21, 52])
arr.max()
# 99
arr.min()
# 2
arr.argmax()
# 5
arr.argmin()
# 7
#+end_src

** ~shape~
(~rows~, ~columns~)
#+begin_src python
np.arange(0, 25).shape # Note that this array would better be displayed
# vertically to match the shape. However, numpy displays it horizontaly.
# (25,)
#+end_src
** ~dtype~
#+begin_src python
arr = np.arange(0, 25, dtype='float16') # intx, uintx, floatx
arr.dtype
# dtype('float16')
#+end_src

** ~size~
Returns the length of the array.
#+begin_src python
a = np.array([3, 1, 5, 2, 5, 1, 1, 5, 1, 4, 2, 1, 4, 5, 3, 4, 5, 2, 4, 2, 6, 6, 3, 6, 2, 3, 5, 6, 5])
a.size
# 20
#+end_src
* Indexing and slicing
** Slicing 1-D
Regular slicing methods used in lists apply. Slice will point to the original
arrays memory, which is not the case in regular lists.
#+begin_src python
l1 = list(range(0, 10))
l2 = l1[:5] # [:] operator shallow copies elements to a new array
l1[1] = 100
l2
# [0, 1, 2, 3, 4]

a1 = np.arange(0, 10)
a2 = a1[:5]
a1[1] = 100
a2
# array([  0, 100,   2,   3,   4])
#+end_src
** ~copy~
#+begin_src python
a1 = np.arange(0, 10)
a2 = a1[:5].copy()
a1[1] = 100
a2
# array([0, 1, 2, 3, 4])
#+end_src
** Broadcasting
#+begin_src python
arr = np.arange(0, 10)
arr[:5] = 100
arr
# array([100, 100, 100, 100, 100,   5,   6,   7,   8,   9])
#+end_src
** Slicing 2-D
Using ~:~ is important when slicing. It changes the shape of the output. Using
~:~ keeps the shape.
#+begin_src python
a = np.arange(0, 100, 5).reshape(4, 5)
a
# array([[ 0,  5, 10, 15, 20],
#        [25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70],
#        [75, 80, 85, 90, 95]])

a[1:3]
# array([[25, 30, 35, 40, 45],
#        [50, 55, 60, 65, 70]])

a[1:3,2:]
# array([[35, 40, 45],
#        [60, 65, 70]])

a[1:, 3:4] # != a[1:, 3]
# array([[40],
#        [65],
#        [90]])
a[1:, 3]
# array([40, 65, 90])
#+end_src

* Conditional selection
Includes a pointer to the original array.
#+begin_src python
a = np.random.randint(0, 10, 20)
a
# array([7, 2, 0, 3, 2, 9, 6, 0, 9, 6, 5, 6, 0, 5, 3, 6, 1, 1, 0, 2])
gt5 = a > 5
a[gt5]
# array([7, 9, 6, 9, 6, 6, 6])

a[gt5] *= 10
# array([70,  2,  0,  3,  2, 90, 60,  0, 90, 60,  5, 60,  0,  5,  3, 60,  1,
#         1,  0,  2])
#+end_src

* Operations
** ~+~, ~-~, ~/~, ~*~
Division by zero will not cause an error. Instead it will issue a warning.
#+begin_src python
a = np.array([5, 7, 1, 0])
a / 2
# array([2.5, 3.5, 0.5, 0. ])

a / a
# 1: RuntimeWarning: invalid value encountered in divide
# array([ 1.,  1.,  1., nan])

a / 0
# 1: RuntimeWarning: divide by zero encountered in divide
# 1: RuntimeWarning: invalid value encountered in divide
# array([inf, inf, inf, nan])
#+end_src
